<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-us" lang="en-us">
<head>
     <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); 
     </script> 
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"> 
     </script> 

  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="generator" content="Hugo 0.31" />

  
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>A Collaborative Filtering Model on tensorflow with Nonlinear Cross Features &middot; Theory of Machines</title>

  
  <link rel="stylesheet" href="https://ozkansafak.github.io/css/print.css" media="print">
  <link rel="stylesheet" href="https://ozkansafak.github.io/css/poole.css">
  <link rel="stylesheet" href="https://ozkansafak.github.io/css/syntax.css">
  <link rel="stylesheet" href="https://ozkansafak.github.io/css/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Abril+Fatface|PT+Sans:400,400i,700">

  
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
  <link rel="shortcut icon" href="/favicon.png">

  
  <link href="" rel="alternate" type="application/rss+xml" title="Theory of Machines" />
</head>

  <body class=" ">
       <script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]} }); 
     </script> 
     <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"> 
     </script> 

<div class="sidebar">
  <div class="container sidebar-sticky">
    <div class="sidebar-about">
      <a href="https://ozkansafak.github.io/"><h1>Theory of Machines</h1></a>
      <p class="lead">
      An elegant open source and mobile first theme for <a href="http://hugo.spf13.com">hugo</a> made by <a href="http://twitter.com/mdo">@mdo</a>. Originally made for Jekyll.
      </p>
    </div>

    <ul class="sidebar-nav">
      <li><a href="https://ozkansafak.github.io/">Home</a> </li>
      
    </ul>

    <p>&copy; 2017. All rights reserved. </p>
  </div>
</div>

    <div class="content container">
    <div class="post">
  <h1>A Collaborative Filtering Model on tensorflow with Nonlinear Cross Features</h1>
  <span class="post-date">Sat, Nov 18, 2017</span>
  

<hr />

<!-- ><p style="color:#cf494f">  $r_{ij}$   </p> -->

<h2 id="1-problem-description">1. Problem Description</h2>

<p>We are given a rating matrix $R$ where only a small fraction of the entries $R_{ij}$ are provided; otherwise the rest is missing. The task is to predict those missing entries. As in most Machine Learning problems the assumption here is that there&rsquo;s an underlying stationary pattern as to how users rate the movies.</p>

<p>By the nature of the problem, $R$ is a sparse matrix, where the sparsity comes not from zero entries but from empty records. Therefor, we represent the training data in 3 columns: $i$: user ID , $j$: movie ID and $R_{ij}$: the rating (see Table 1).</p>

<p><font size="+1"><strong><p align="center">Table 1. Ratings data ml-20m sparse format</p></strong></font></p>

<table>
<thead>
<tr>
<th align="center">$i$: user ID</th>
<th align="center">$j$: movie ID</th>
<th align="center">$R_{ij}$: the rating</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">0</td>
<td align="center">14</td>
<td align="center">3.5</td>
</tr>

<tr>
<td align="center">0</td>
<td align="center">7305</td>
<td align="center">4.0</td>
</tr>

<tr>
<td align="center">0</td>
<td align="center">16336</td>
<td align="center">3.5</td>
</tr>

<tr>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>

<tr>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">52</td>
<td align="center">4.0</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">986</td>
<td align="center">4.0</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">1455</td>
<td align="center">3.5</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">1705</td>
<td align="center">5.0</td>
</tr>

<tr>
<td align="center">1</td>
<td align="center">5598</td>
<td align="center">4.0</td>
</tr>

<tr>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>

<tr>
<td align="center">.</td>
<td align="center">.</td>
<td align="center">.</td>
</tr>

<tr>
<td align="center">138493</td>
<td align="center">27278</td>
<td align="center">5.0</td>
</tr>
</tbody>
</table>

<hr />

<h2 id="2-collaborative-filtering-model">2. Collaborative Filtering Model</h2>

<p>The terms <em>Collaborative Filtering</em>, <em>Matrix Factorization</em> and <em>Low-Rank Matrix Factorization</em> all refer to the same recommender system model. In essence, this model is based on the assumption that users who liked the same movies are likely to feel similarly towards other movies. The term <em>collaborative</em> refers to the observation that when a large set of users are involved in rating the movies, these users are effectively collaborating to get better movie ratings for everyone because every new rating will help the algorithm learn better features for the <em>users-movies</em> system. Later, these features are used by the model to make better rating predictions for everyone.</p>

<p>The Collaborative Filtering Model can also be described as reconstructing a <strong>low rank approximation</strong> of matrix $R$ via its <strong>Singular Value Decomposition</strong> $R = U \cdot \Sigma \cdot V^T$. The low-rank reconstruction is achieved by only retaining the largest $k$ singular values, $R_k=U \cdot \Sigma_k \cdot V^T$.</p>

<p><strong>Eckart-Young Theorem</strong> states that if $R_k$ is the best rank-$k$ approximation of $R$, then it&rsquo;s necessary that:</p>

<p>&emsp;&emsp;&emsp;   1. $R_k$ minimizes the Frobenius norm $||R-R_k||_F^2$ and<br />
&emsp;&emsp;&emsp;   2. $R_k$ can be constructed by retaining only the largest $k$ singular values in $\Sigma_k$ of the SVD formulation.</p>

<p>We can further absorb the diagonal matrix $\Sigma_k$ into $U$ and $V$ and express the factorization as a simple dot product between the feature matrices for users and movies.</p>

<p align="center">$R_{k(m \times n)} = U_{(m \times k)} \cdot V_{(k \times n)}^T$</p>

<p>where, the parentheses indicate matrix size.<br />
$m$: number of users ($m = 138493$)<br />
$n$: number of movies ($n = 27278$)<br />
$k$: rank hyperparameter that we impose (typically $k=10$).<br />
$U$: user feature matrix<br />
$V$: movies feature matrix</p>

<p><img src="/Drawing.png" alt="Drawing" width="1000" />
<font size="+1"><strong><p align="center">Figure 1. A conceptual sketch of the Ratings data matrix $R$ decomposed into its factors: user feature matrix, $U$, and movie feature matrix, $V$. Dots in the figure, $\cdot$, illustrate given values; and question marks, $?$, the missing values. Each entry $r_{ij}$ is expressed as a dot product of the user and movie embedding vectors $u_i$ and $v_j$, respectively.</strong></font></p>

<p>Hence, we formulate the problem as an <strong>optimization problem</strong> and search for $U$ and $V$ by minimizing the following loss function $L$.</p>

<p>$$argmin_{\ U,V}\ L = ||R - U \cdot V^T||_F^2$$</p>

<blockquote>
<p><em>An important point to make is that the Frobenius norm is computed only as a partial summation over the entries in $R$ where a rating is provided.</em></p>
</blockquote>

<p>The optimization procedure searches for the values of all entries in $U$ and $V$. There are $(m+n) \times k$ many tunable variables.</p>

<p>The hyperparameter $k$ is to be chosen carefully by cross-validation. A small $k$ would not be enough to explain the pattern in the data adequately (<em>underfitting</em>), and too large a $k$ value would result in a model fitting on the random noise over the pattern (<em>overfitting</em>).</p>

<blockquote>
<p><em>It&rsquo;s worth making a brief interpretation of the feature matrices $U$ and $V$. In the $k$-rank approximation scheme, each rating $r_{ij}$ is expressed by the dot product $u_i \cdot v_j^T$ (see Figure 1). The goal of our optimization routine is for the model to learn a</em> <strong><em>latent feature representation</em></strong> <em>(or alternatively an</em> <strong><em>embedding vector</em></strong>) <em>for each user and movie.</em><br />
<br />
<em>The term</em> <strong><em>latent</em></strong> <em>implies that the features are not explicitly defined by us nor they&rsquo;re definitively interpretable once the embeddings are learned by the model. Each entry in the embedding vectors $u_i$ and $v_j$ corresponds to the weight coefficient of an abstract feature. These features can specify the movie genre,  how action-filled or dramatic or any other distinguishing quality that would help characterize how the users rate movies. Hence, the dot product representation of the ratings $r_{ij} = u_i \cdot v_j^T$ points to a</em> <strong><em>linear combination</em></strong> <em>of<br />
<br />
&emsp;&emsp;&emsp; 1. how much that feature is contained in the movie, and<br />
&emsp;&emsp;&emsp; 2. how much that feature is favored by the user.</em></p>
</blockquote>

<h2 id="3-practical-methodology">3. Practical Methodology</h2>

<h5 id="movielens-20m-dataset">MovieLens 20M dataset</h5>

<ul>
<li><a href="https://grouplens.org/datasets/movielens/20m/">MovieLens dataset</a> data set consists of 20,000,263 ratings from 138,493 users on 27,278 movies.</li>
<li>All ratings are given at intervals of 0.5:<br />
{0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0, 4.5, 5.0}</li>
<li>Shuffling the data before splitting it into training, CV and test sets was crucial.</li>
<li>Splitting the Input Data:

<ul>
<li>Training Data takes up 64% of the input data,</li>
<li>CV Data 16% and</li>
<li>Test Data 20%.</li>
</ul></li>
<li>We abstain from imposing a <strong>bias term</strong> by enforcing an extra component set to constant $1$ in $U$ and $V$, since the embeddings are free to learn biases if necessary.</li>
<li>Since no particular bounds are imposed on the entries in the embedding vectors $u_{i}$ and $v_{j}$. The model is free to learn positive or negative real numbers.<br /></li>
</ul>

<p><div style="width:700 px">
    <div style="float:left; width:360">
        <img src="/fig1.png" alt="fig1" width="360" />
    </div>
    <div style="float:left; width:300">
        <img src="/fig2.png" alt="fig2" width="360" />
    </div>
    <div style="float:left; width:300">
        <img src="/fig3.png" alt="fig3" width="360" />
    </div>
    <div style="float:left; width:300">
        <img src="/fig4.png" alt="fig4" width="360" />
    </div>
    <div style="clear:both"></div>
</div>
<br>
<font size="+1"><b><p align="center">Figure 2. Histogram of (<em>a</em>) all ratings in ml-20m data (<em>b</em>) mean of ratings per user (<em>c</em>) mean of ratings per movie, and (<em>d</em>)
    number of ratings provided by users. Minimum number of ratings provided by a user is 20, and maximum is 9254 ratings.
</p></b></font></p>

<hr />

<h2 id="4-challenges-in-developing-the-model-on-tensorflow">4. Challenges in Developing the Model on <code>tensorflow</code></h2>

<ul>
<li><p>A particular challenge in implementing a Matrix Factorization algorithm on <code>tensorflow</code> is that we can&rsquo;t naively pass <code>None</code> for the <code>shape</code> argument while declaring the input data tensors <code>R</code> and <code>R_indices</code> as in <code>R = tf.placeholder(..., shape=(None))</code>.  The <code>shape</code> parameter corresponds to the number of ratings a single batch in the SGD step contains. To make the SGD work, I had to fix the <code>shape</code> of the <code>tf.placeholder</code> variables <code>R</code> and <code>R_indices</code>  to <code>shape=(BATCH_SIZE, k)</code> instead of <code>shape=(None, k)</code>.  This is a small price to pay that allows me to use <code>tensorflow</code> which provides me GPU computation and also backprop with symbolic differentiation. This gave me the flexibility to experiment with additional nonlinear terms in loss function without having the worry about the partial differentials with respect to the tunable variables.</p>

<pre><code class="language-python">R = tf.placeholder(dtype=tf.float32, shape=(BATCH_SIZE,))
R_indices = tf.placeholder(dtype=tf.int32, shape=(BATCH_SIZE,2))
u_mean = tf.placeholder(dtype=tf.float32, shape=(BATCH_SIZE,1)) 
v_mean = tf.placeholder(dtype=tf.float32, shape=(BATCH_SIZE,1)) 
</code></pre></li>

<li><p>At each SGD step a mini-batch of rating data $R_{ij}$ and the corresponding user-movie index pairs $(i,j)$ are fed into the computational graph. Since each $R_{ij}$ is represented as the dot product $u_i \cdot v_j^T$, we have to stack the corresponding embedding vectors into 2-D tensors <code>U_stack</code> and <code>V_stack</code> where both <code>U_stack.getshape()</code> and <code>V_stack.getshape()</code> equal to <code>(BATCH_SIZE,k)</code>.<br />
The implementation of stacking tensors <code>tensorflow</code> is a little trickier than in <code>numpy</code>, and it&rsquo;s implemented in the following <code>get_stacked_UV</code> module:</p>

<pre><code class="language-python">def get_stacked_UV(R_indices, R, U, V, k, BATCH_SIZE):
u_idx = R_indices[:,0]
v_idx = R_indices[:,1]
rows_U = tf.transpose(np.ones((k,1), dtype=np.int32)*u_idx)
rows_V = tf.transpose(np.ones((k,1), dtype=np.int32)*v_idx)
cols = np.arange(k, dtype=np.int32).reshape((1,-1))
cols = tf.tile(cols, [BATCH_SIZE,1])

indices_U = tf.stack([rows_U, cols], -1)
indices_V = tf.stack([rows_V, cols], -1)

stacked_U = tf.gather_nd(U, indices_U)
stacked_V = tf.gather_nd(V, indices_V)
    
return stacked_U, stacked_V
</code></pre></li>
</ul>

<hr />

<h2 id="5-linear-and-nonlinear-features">5. Linear and Nonlinear Features</h2>

<ul>
<li><p><code>R_pred = tf.sigmoid(R_pred) * 5</code> dropped the <code>MAE_test</code> approximately from <code>.64</code> to <code>.62</code>. The reason for it is that the error rate, in the absence of sigmoid activation, some predictions can get bigger than 5 and some smaller than 0. Sigmoid activation brings the predictions closer to their actual values.</p></li>

<li><p>However, adding squared dot product term along with the linear dot product, didn&rsquo;t produce any tangible improvement and was discarded from the final model.</p>

<pre><code class="language-python">u_cdot_v_square = tf.square(tf.multiply(U_stack_, V_stack)) 
nl = tf.reduce_sum(u_cdot_v_square, axis=1)
R_pred = R_pred + alpha*nl
R_pred = tf.sigmoid(R_pred) * 5
</code></pre></li>
</ul>

<h2 id="6-cross-features">6. Cross Features:</h2>

<ul>
<li><p>In the linear collaborative filtering model, $$R_{ij} = U_{i} \cdot V_{j}^T$$ $p^{th}$ feature of $U_{i}$ is multiplied with the corresponding $p^{th}$ feature of $V_{j}$.<br />
$$=&gt; Linear\ Model: MAE (CV) = 0.6237$$</p></li>

<li><p>The rating prediction with cross-features:
$$r_{ij} = u_{i} \cdot v_{j}^{T} + \sum_{p=0}^{k}\sum_{q=0}^{k} w_{pq} (u_{ip} \cdot v_{jq}^{T})$$</p></li>

<li><p>Here, $p^{th}$ feature of user $i$ is getting multiplied with $q^{th}$ feature of movie $j$. This allows the model to learn cross interactions as, for instance, if a user likes the actor Tom Cruise (the $p^{th}$ feature&ndash;high  value for $u_{ip}$), and she doesn&rsquo;t like dark and suspenseful thrillers ($q^{th}$ feature&ndash;low value for $u_{iq}$), however, she likes the movie Eyes Wide Shut (even though it has a high value for $v_{jq}$), because an underlying reason that makes her not like dark suspenseful movies perhaps disappears if Tom Cruise is in the movie. For a model to capture such a pattern, it has to allow some sort of <strong>nonlinear cross interactions</strong> between features $p$ and $q$.<br />
$$=&gt; Nonlinear\ Model: MAE (CV) = 0.6150$$</p>

<pre><code>R_pred = np.dot(U,V) + alpha1*(xft) + alpha2*(uv_sq)
</code></pre></li>

<li><p>The computational price paid for a mere 1% increas in mae rate is that the runtime for one epoch went from $31$ sec for pure linear model to $60$ sec when incorporating all 3 types of nonlinear feature crossings:<br />
<p align="center">($u_{ip}$ ~ $v_{jq}$),&nbsp; ($u_{ip}$ ~ $u_{iq}$),&nbsp; ($v_{jp}$ ~ $v_{jq}$)</p></p></li>
</ul>

<h2 id="7-improvements-on-the-algorithm">7. Improvements on the Algorithm</h2>

<ol>
<li>The regularization term needs to take into account the average rating for each user $u_i$, $\mu_{u_i}$.</li>
</ol>

</div>


    </div>

    
  </body>
</html>